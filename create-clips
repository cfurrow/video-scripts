#!/usr/bin/env ruby

# Uses ffmpeg to create clips from a video file.
#
#== Usage:
# create-clips [options] <video_file> <output_dir>

require 'optparse'

class ClipOptionErrors
  def initialize
    @errors = {}
  end

  def add(field, message)
    @errors[field] ||= []
    @errors[field] << message
  end

  def any?
    !@errors.empty?
  end

  def to_s
    output = ""
    @errors.each do |field, messages|
      output << "Error in #{field}: #{messages.join(', ')}\n"
    end
    output
  end
end

class ClipOptions
  attr_accessor :input_file, :output_dir, :timestamp_file, :dry_run

  attr_accessor :errors

  def initialize
    @errors = ClipOptionErrors.new
  end

  def valid?
    errors.add(:input_file, "Input file is required.") if input_file.nil?
    errors.add(:output_dir, "Output file is required.") if output_dir.nil?
    errors.add(:input_file, "\"#{input_file}\" does not exist!") unless File.exist?(input_file || "")
    errors.add(:output_dir, "\"#{output_dir}\" does not exist!") unless Dir.exist?(output_dir || "")

    # TODO: If timestamp_file is not specified, try to use the input_file name with a "txt" extension, then check if it exists

    errors.add(:timestamp_file, "Timestamp file is required.") if timestamp_file.nil?
    errors.add(:timestamp_file, "#{timestamp_file} does not exist!") unless File.exist?(timestamp_file)
    
    !errors.any?
  end
end

class TimestampFile
  TIMESTAMP_LINE = /(?<time>\d{1,2}:\d{2}:\d{2})\s+(?<description>.*?)$/

  attr_reader :clips, :path

  def initialize(path)
    @path = path
    @clips = []
  end

  def parse!
    @clips = []
    File.open(path, "r") do |file|
      file.each_line do |line|
        @clips << create_clip_from_line(line)
      end
    end

    # We need to populate the end_time of each clip to the start time of the next clip
    @clips.each_with_index do |clip, index|
      if index < @clips.length - 1
        clip.end_time = @clips[index + 1].start_time
      end
    end

    @clips
  end

  def create_clip_from_line(line)
    line_details = line.match(TIMESTAMP_LINE)

    return if line_details.nil?
    time = line_details[:time]
    description = line_details[:description]

    Clip.new(nil, time, nil, description)
  end
end

class Clip
  attr_reader :file, :start_time, :end_time, :description
  
  def initialize(file, start_time, end_time, description)
    @file = file
    @start_time = start_time
    @end_time = end_time
    @description = description&.tr('"', '')&.tr('/', '\/')&.tr('\\', '-')&.tr('\'', '')
    @output_dir = nil
  end

  def file=(file_path)
    @file = file_path
  end

  def end_time=(new_end_time)
    @end_time = new_end_time
  end

  def to_s
    "#{start_time} - #{end_time} #{description}"
  end

  def clip!(output_directory)
    @output_dir = output_directory
    puts "Clipping #{output_file}..."
    puts command
    system(command)
  end

  def command
    "ffmpeg -ss #{start_time} -i \"#{file}\" #{end_time_option} -codec copy -avoid_negative_ts make_zero -y \"#{output_file}\""
  end

  private

  def input_filename
    File.basename(file, '.*')  # remove extension
  end

  def output_file
    @output_dir = "#{@output_dir}/" if @output_dir && !@output_dir.end_with?("/")
    "#{@output_dir}#{input_filename}.#{description}.clip.mp4"
  end

  def end_time_option
    return "" if end_time.nil?
    
    "-to #{end_time}"
  end
end

options = ClipOptions.new

OptionParser.new do |opts|
  opts.banner = "Usage: create-clips [options] <video_file> <output_dir>"

  opts.on("-h", "--help", "Display this help message.") do
    puts opts
    exit
  end

  opts.on("-fPATH", "--from_file=PATH", "Create clips from timestamps file") do |f|
    options.timestamp_file = f
  end

  opts.on("-d", "--dry_run", "Dry run, don't actually create clips") do
    options.dry_run = true
  end
end.parse!

options.input_file = ARGV[0]
options.output_dir = ARGV[1]

unless options.valid?
  puts options.errors
  exit 1
end

# TODO: current problem is in docker env. If ruby is in a container, and ffmpeg in another container, this won't work.
clips = TimestampFile.new(options.timestamp_file).parse!
clips.map do |clip|
  clip.file = options.input_file
end

if options.dry_run
  clips.each do |clip|
    puts clip.command
  end
else
  clips.each do |clip|
    puts clip.clip!(options.output_dir)
  end
end


